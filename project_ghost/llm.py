import json
import os
import yaml
from openai import OpenAI
import re

# ==== æ ¹ç›®å½•è®¾ç½® ====
BASE_OUTPUT_DIR = "/home/xuehuanhuan/2.LATTE/sample/heper"
CONFIG_PATH = "/home/xuehuanhuan/2.LATTE/project_ghost/config.yaml"

# ==== æ¨¡æ¿å­—ç¬¦ä¸² ====
END_SYSTEM_TEMPLATE = (
    "You are a static analysis expert performing the final vulnerability evaluation step.\n"
    "You are given the last function in the call chain that calls a known goal_sink (e.g., strcpy, memcpy, snprintf, etc.).\n"
    "The provided [CALL_CONTEXT] gives the actual argument conditions at the time of this call â€” use only this real context for reasoning.\n\n"
    "Task: Determine whether the call constitutes a CWE-134 vulnerability\n"
    "Base your reasoning strictly on the provided argument sizes, value ranges, and any bounds or sanitization checks observed in the code.\n"
    "Do not speculate about other inputs or unseen code.\n\n"
    "Output format: Begin your answer with **'Yes'** or **'No'**, followed by a short explanation (1â€“3 sentences) describing the key reason for your decision."
)

END=(
"You are a static analysis expert evaluating potential vulnerabilities.\n"
"Your specific task in this run is to determine whether a given call constitute a **CWE-134: Uncontrolled Format String** vulnerability.\n"
"Use only the real argument details in [CALL_CONTEXT](gives the actual argument conditions at the time of this call).\n"
"Each argument entry may include fields such as:\n"
"  - param_index: its position in the function call,Begin from 1\n"
'  - usr: "yes" if the argument is tainted or user-controlled, otherwise "no"\n'
'  - other_info: may describe semantic roles like "format string", "destination buffer", "stdout", etc.\n'
"  - buf_size, value_range: optional contextual hints\n"
'"Signature" provides the exact function call signature at this call site.\n'
"Be concise and deterministic. Do not speculate about unseen code or inputs.\n"
"{code}"
)

SYSTEM_TEMPLATE = (
    "You are a static analysis expert performing function-level reasoning along a call chain.\n"
    "Goal: For each given function and its call context (provided in [CALL_CONTEXT]), summarize:\n "
    "(a) how taint-like values (from param) propagate from this function to callee or goal_sink;\n "
    "(b) which calls this function makes, with argument constraint details from (a), for next step analysis\n"
    "\n"
    "Output: Return exactly one JSON object on a single line (no Markdown/prose beyond `note`). "
    'Use EXACTLY these keys (keep arrays minimal; use "unk" for not sure):\n'
    "{"
    '"fn":"string",'
    '"calls":[{"callee":"str","signature":"str","args":[{"arg_index":int,"buf_size":"str|unk","value_range":"str|unk","user":"yes|no","other_info":"str"}]}],'
    '"goal_sink":["string"],'
    '"note":"brief natural info if truly useful"'
    "}\n"
    "RULES:\n"
    "- Report only facts from THIS function or explicit user context; do NOT restate code.\n"
    "- Signature is the *function call point* signature instead of funcion declaration. For example: 'x1=foo(x1,y1)' in main()\{int x1,x2,y1=1,2,3;x2=foo(x1,y1); return 0;\} \n"
    '- Always list ALL function calls in "calls". If this function itself have a func_call about target sink, analyze potential vulnerability, otherwise copy it to output\n'
    '- Keep parameter features relevant to overflow or taint propagation (e.g., buf_size for arrays, value_range for integers)."other_info" = any necessary info.\n'
    '- "user" = whether the variable is usr-controlled.If Arg is format string,it is not usr-controlled'
    '- Arg_index begins from 1. Use [] or "unk" for missing or unknown fields. Use "note" for concise but necessary supplementary information (e.g., global access, sanitization check).\n'
    "CONTEXT / INHERIT:\n"
    "- If the user message includes a [CALL_CONTEXT] with arg_hints, it indicates the callers constraints on this functions arguments; you should only consider the parameters of the current function under these given conditions.\n"
    "- Your json will be used to build context for the next function in the call chain,be sure to be accurate and complete.\n"
)

START_TEMPLATE = (
    "As a program analyst, I give you snippets of C code generated by decompilation, "
    "This is the first function in the call chain â€” it has no caller context.\n"
    "A known taint source '{source}' is introduced here, and the goal_sink is '{sink}'.\n"
    "Analyze the decompiled C code below to trace how data derived from '{source}' propagates within this function, "
    "including aliases, assignments, and calls that may pass tainted values forward.\n\n"
    "{code}"
)

MIDDLE_TEMPLATE = (
    "Analyze the following function using the provided upstream [CALL_CONTEXT]. "
    "Initialize parameter details from arg_hints (match by arg_index), and reason only within this function â€” do not speculate beyond given facts. "
    "For each call made here (including library or sink calls), record it in the 'calls' array with relevant argument details. "
    "Base your reasoning solely on this code and the given context.\n\n"
    "{code}"
)

END_TEMPLATE = (
    "Below is the sink in the call chain along with its call context.\n"
    "Use the argument details provided in [CALL_CONTEXT] and the feature of this sink to decide whether this call  represents a CWE-134 vulnerability.\n\n"
    "{code}"
)

S_TEMPLATE = (
    "You are a static analysis expert performing function-level reasoning.\n"
    "Goal: For a given function, summarize:\n "
    "(a) Trace how data derived from '{source}' propagates from this function to any callee.\n"
    "(b) trace func_calls this function makes, with argument constraint details, for next step analysis\n"
    "\n"
    "Output: Return exactly one JSON object on a single line (no Markdown/prose beyond `note`). "
    'Use EXACTLY these keys (keep arrays minimal; use "unk" for not sure):\n'
    "{"
    '"fn":"string",'
    '"calls":[{"callee":"str","signature":"str","args":[{"arg_index":int,"buf_size":"str|unk","value_range":"str|unk","user":"yes|no","other_info":"str"}]}],'
    '"goal_sink":["string"],'
    '"note":"brief natural info if truly useful"'
    "}\n"
    "RULES:\n"
    "- Report only facts from THIS function or explicit user context; do NOT restate code.\n"
    "- Signature is the *function call point* signature instead of funcion declaration. For example: 'x1=foo(x1,y1)' in main()\{int x1,x2,y1=1,2,3;x2=foo(x1,y1); return 0;\} \n"
    '- Always list ALL function calls in "calls". If this function itself have a func_call about target sink, analyze potential vulnerability, otherwise copy it to output\n'
    '- Keep parameter features relevant to overflow or taint propagation (e.g., buf_size for arrays, value_range for integers)."other_info" = any necessary info.\n'
    '- "user" = whether the variable is usr-controlled.If Arg is format string,it is not usr-controlled'
    '- Arg_index begins from 1. Use [] or "unk" for missing or unknown fields. Use "note" for concise but necessary supplementary information (e.g., global access, sanitization check).\n'
    "CONTEXT / INHERIT:\n"
    "- If the user message includes a [CALL_CONTEXT] with arg_hints, it indicates the callers constraints on this functions arguments; you should only consider the parameters of the current function under these given conditions.\n"
    "- Your json will be used to build context for the next function in the call chain,be sure to be accurate and complete.\n"
)
# ==== å·¥å…·å‡½æ•° ====
FUNC_NAME_RE = re.compile(r"\b([A-Za-z_]\w*)\s*\(")

def extract_fn_name(code: str) -> str:
    m = FUNC_NAME_RE.search(code)
    return m.group(1) if m else ""

def print_messages(messages):
    for msg in messages:
        print(f"\n[{msg['role'].upper()}]")
        print(msg["content"])

def build_call_context_for(messages, target_fn: str) -> str:
    def parse_assistant_json(text: str):
        text = text.strip()
        try:
            return json.loads(text)
        except Exception:
            try:
                start = text.find("{")
                end = text.rfind("}")
                if start != -1 and end != -1:
                    return json.loads(text[start:end + 1])
            except Exception:
                return None
        return None

    for msg in reversed(messages):
        if msg.get("role") == "assistant":
            data = parse_assistant_json(msg.get("content", ""))
            if not isinstance(data, dict):
                continue
            calls = data.get("calls") or []  # è·å–è°ƒç”¨åˆ—è¡¨
            caller = data.get("fn") or ""  # è·å–è°ƒç”¨è€…å‡½æ•°å
            sink = data.get("goal_sink") or []    # è·å–sinkåˆ—è¡¨
            note= data.get("note") or "None"
            for call in calls:
                if str(call.get("callee")) == target_fn: # æ‰¾åˆ°ç›®æ ‡å‡½æ•°è°ƒç”¨,è‹¥æ­£æ˜¯éœ€è¦çš„
                    sign=call.get("signature") or "unk"
                    args = call.get("args") or [] # è·å–å‚æ•°åˆ—è¡¨
                    slim_args = [
                        {
                            "param_index": a.get("arg_index", 0),
                            "buf_size": str(a.get("buf_size", "unk")),
                            "value_range": str(a.get("value_range", "unk")),
                            "user": str(a.get("user", "No")),
                            "other_info": str(a.get("other_info", "None")),
                        }
                        for a in args
                    ]
                    ctx = "[CALL_CONTEXT]\n" f"caller:{caller} to callee: {target_fn}\n" +f"function call signature:{sign}\n"+f"arg_hints:" + json.dumps(slim_args, separators=(",", ":")) + "\n" + f"Extra note:{note}\n"+f"target sink:{sink}\n"
                    return ctx
    return ""

# ==== ä¸»åˆ†æå‡½æ•° ====
def analyze_flow(flow: dict, client, model, api_base):
    source = flow.get("source") # sourceåç§°
    sink = flow.get("sink") # sinkåç§°
    func_keys = sorted(int(k) for k in flow if k.isdigit()) # int key
    funcs = [flow[str(i)] for i in func_keys] # å¯¹åº”çš„ç¨‹åºä»£ç ,è¦ä¼˜åŒ–å°±æ˜¯è¿™é‡Œäº†
    messages = [{"role": "system", "content": SYSTEM_TEMPLATE}] # ç³»ç»Ÿæ¨¡æ¿
    start_msg = START_TEMPLATE.format(source=source, sink=sink, code=funcs[0])
    messages.append({"role": "user", "content": start_msg})

    response = client.chat.completions.create(model=model, messages=messages, temperature=0.2) # æŠ•è¿›SYSTEMå’ŒSTART,æœ‰ç¬¬ä¸€ä¸ªå‡½æ•°
    messages.append({"role": "assistant", "content": response.choices[0].message.content})

    for code in funcs[1:]:
        target_fn = extract_fn_name(code)  # è¿”å›å‡½æ•°åç§°
        call_ctx = build_call_context_for(messages, target_fn)
        middle_msg = MIDDLE_TEMPLATE.format(code=(call_ctx + code))
        tmp_messages = [{"role": "system", "content": SYSTEM_TEMPLATE}, {"role": "user", "content": middle_msg}]
        messages.append({"role": "user", "content": tmp_messages})
        response = client.chat.completions.create(model=model, messages=tmp_messages, temperature=0.2)
        messages.append({"role": "assistant", "content": response.choices[0].message.content})
        
    call_ctx = build_call_context_for(messages, sink)
    end_msg = END_TEMPLATE.format(code=call_ctx)
    tmp_messages = [{"role": "system", "content": END_SYSTEM_TEMPLATE}, {"role": "user", "content": end_msg}]
    messages.append({"role": "user", "content": tmp_messages})
    response = client.chat.completions.create(model=model, messages=tmp_messages, temperature=0.2)
    messages.append({"role": "assistant", "content": response.choices[0].message.content})
    return response.choices[0].message.content,messages


# ==== ä¸»ç¨‹åº ====
def main():
    # === è·å–LLMå‚æ•° ===
    if not os.path.isfile(CONFIG_PATH):
        raise FileNotFoundError(f"Missing config: {CONFIG_PATH}")
    with open(CONFIG_PATH, "r", encoding="utf-8") as f:
        cfg = yaml.safe_load(f)
    api_key = cfg.get("OPENAI_API_KEY")
    if not api_key:
        raise RuntimeError("OPENAI_API_KEY missing in config.yaml")
    api_base = cfg.get("API_BASE", "https://api.openai.com/v1")
    model = cfg.get("MODEL", "gpt-4o-mini")
    client = OpenAI(api_key=api_key, base_url=api_base)

    # === éå†æ‰€æœ‰å­æ–‡ä»¶å¤¹ ===
    for subdir in os.listdir(BASE_OUTPUT_DIR):
        sub_path = os.path.join(BASE_OUTPUT_DIR, subdir)
        if not os.path.isdir(sub_path):
            continue

        vuln_output_path = os.path.join(sub_path, "vuln_output.json")
        result_path = os.path.join(sub_path, "vuln_analysis_results.json")
        if not os.path.isfile(vuln_output_path):
            print(f"[è·³è¿‡] {subdir}: æœªæ‰¾åˆ° vuln_output.json")
            continue

        print(f"\n=== åˆ†ææ–‡ä»¶å¤¹: {subdir} ===")
        with open(vuln_output_path, "r", encoding="utf-8") as f:
            data = json.load(f)

        results = {}
        for vid, flow in data.items():
            print(f"Analyzing {vid} in {subdir}...") # vidæ˜¯vuln0,vuln1...
            try:
                result,messages = analyze_flow(flow, client, model, api_base)
            except Exception as e:
                result = f"Error during analysis: {e}"
            results[vid] = result
            
            print(f"--- {vid} Result ---\n{result}\n\n\n")
            for msg in messages:
                role = msg.get("role", "").upper()
                content = msg.get("content", "")
                if isinstance(content, str):
                    content = content.encode("utf-8").decode("unicode_escape")
                elif isinstance(content, list):
                    content = "\n".join(str(x) for x in content)
                elif isinstance(content, dict):
                    content = json.dumps(content, ensure_ascii=False, indent=2)
                else:
                    content = str(content)

                print(f"\n[{role}]\n{content}\n")


        with open(result_path, "w", encoding="utf-8") as f:
            json.dump(results, f, ensure_ascii=False, indent=2)

        print(f"âœ… {subdir} åˆ†æå®Œæˆ")

    print("ğŸ¯ æ‰€æœ‰æ–‡ä»¶å¤¹åˆ†æå®Œæˆï¼")


if __name__ == "__main__":
    main()
